# 基础

## 数据类型

- 基本数据类型：Number、Boolean、String、Null、Undefined、System(ES6新增)、Bigint(ES10新增)
- 引用数据类型：Object(function、array、Date、Math等)

`typeof`操作符可以用来确定任意变量的数据类型，返回值：`"undefined"`、`"boolean"`、`"string"`、`"number"`、`"object"`、`"number"`、`"object"`、`"function"`、`"symbol"`

`typeof` `string`、`boolean`、`number`、`object`、`function`、`undefined`都会返回相应的字符串形式，array会返回`"object"`；null会返回`"object"`,因为null被认为空对象引用。

函数在ECMAScript中被认为是对象，并不代表数据类型。typeof操作返回function, 就是因为函数有自己特殊的属性。为此就有必要通过typeof操作符来区分函数和其他对象。

`undefined` 一般情况下使用`void 0`表示，因为`undefined`不是关键字可以当做变量名使用

`undefined` 和 `null` 区别

- undefined可以认为是系统级别的，如果一个变量没有赋值，那么默认为undefined, null是应用级别的，所以说永远不要显示地设置值为undefined
- undefined值是由null值派生而来的

## Number 

JS不区分整数类型与浮点类型，所有值均使用浮点类型表示。采用IEEE 754标准定义64位浮点格式表示数字，这意味着它能表示的最大值为±1.7976931348623157e308`Number.MAX_VALUE`，最小值±5e-324`Number.MIN_VALUE`。（安装JS的数字格式，能够表示整数范围是从-9 007 199 254 420 992 ~ 9 007 199 254 420 992，也就是±2^53，包含边界值。如果超出这个范围就无法保证低位数字的精度，然而JS中实际操作则是基于32位,操作完成转为64位。） ，如果超出了JS表示范围，那么这个值就会转换为`Infinity（无穷）`值。任何无法表示的负数以`-Infinity（负无穷）`表示。

如果是为`±Infinity`，该值就不能进一步计算了，这是因为它没有可用于计算的数值表示形式。可以用`isFinite()`判断一个值是否在`±Infinity`之间（Finite检测传入的参数是否是一个有穷数）。也可以使用`Number.NEGATIVE_INFINITY`判断是否为`-Infinity`,`Number.POSITIVE_INFINITY`判断是否为`Infinity`。

当数字运算结果超过JS所能表示的数字上线（溢出），结果为一个特殊的无穷大（infinity）值, JS以Infinity表示，同样负数超出时候用-Infinity表示，计算的符号位还是不变的。

被0整除程序不会报错，会返回±Infinity， 有一个例外0 除以 0 这种没有意义的，是一个非数字（not-a-number）值，用NaN表示。无穷大除以无穷大、给任意负数做开方运算、算术运算符与不是数字或无法转换为数字的操作数一起使用时都将返回NaN。

JS预定义全局变量：Infinity、NaN。在ES3的时候是可以修改的，ES5修正了这个错误。

下溢（underflow）是当运算结果无限接近于零并比JS能表示的最小值还小发生的情况，这种情况下JS会返回0，当一个负数发生下溢的时候会返回-0，这个和0是一样的。

数字计算有上下溢出，那么还有非法计算，那么就会返回`NaN`,代表不是一个数值。对NaN进行操作，都会返回NaN。可以使用`isNaN()`判断是否是NaN，也可以使用`x != x`来判断，因为NaN它和任何值都不想等，包括自身



`isNaN()`接收一个任意类型参数进行判断是否为NaN, 会进行隐式类型转换，然后判断这个值是否“不是一个数值”。（首先调用对象的valueOf()方法，然后判断返回的值是否可以转换为数值。如果不能再调用toString()方法，并返回值）

```javascript
// 在ECMAScript中，0、+0、-0相除会返回NaN 
0 / 0
-0 / +0

// 如果分子是非0值，分母是有无符号0，则会返回Infinity或Infinity
5 / 0
5 / -0

// isNaN
isNaN(NaN) // true
isNaN(10) // false
isNaN("10") // true 
isNaN("blue") // false 
isNaN(false) // true 转换数值0
```

进制表示：二进制（0b开始），八进制（0、0o、0O开始），十六进制数字（0x 或 0X开始）。注意如果8进制赋值，以0开始,如果超出8进制范围则会解析为十进制，比如079，则会解析为79, 编辑器里面也会报错：`Octal literals are not allowed. Use the syntax '0o79'.javascript`不允许使用8进制文字，请使用0o79文字，使用0o79编译器也会报错，不符合预期，浏览器直接运行也会报错。


::: tip 数字错误
实数有无数个，但JS通过浮点数的形式只能表示其中有限个数（确切来说18 437 736 874 454 810 627个）。也就是说，当JS中使用实数的时候，常常只是真实值的一个近似表示。

JS采用IEEE754浮点数表示（几乎所有语言都是），这是一种二进制表示法，可以精确地表示分数。遗憾的是我们一般常用十进制分数表示。二进制浮点数表示法并不能精确表示类似0.1这样简单的数字。例如：`0.3 - 0.2 === 0.2 - 0.1`， 答案是false, `0.2 - 0.1 === 0.1`, 返回true, 但是`0.3 - 0.2 === 0.1` 并不是返回true。 由于舍入误差，0.3 - 0.2之间的近似差值实际上并不等于0.2 - 0.1之间的近似差值，这个问题不只是JS中才会出现，在任何使用二进制浮点类型编程语言中都有这个问题。上面两个计算都是非常接近最终的确定值。这种计算可以胜任大多数计算任务：这个问题也只有在比较两个值是否相等的时候才会出现。
:::

[类型转换官方文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2)

**隐式类型转换**

- 数值比较，直接比较，不进行转换
- 字符串js会进行Number处理，然后数值比较
- boolean 也会使用Number处理，然后数值比较
- 对象与数值比较：
  - 判断对象是否具有valueOf方法，且调用返回一个原始值，js将其转换为数字
  - 否则，判断对象是否具有toString()方法，且调用返回一个原始值，js将其转换为数字
  - 否则JS抛出一个类型错误

**显示类型转换**

有三个函数将非数值转换为数值：`Number()`、`parseInt()`、`parseFloat()`

- Number规则：
  - boolean值true -> 1, false -> 0
  - 数值直接返回
  - null -> 0
  - undefined -> NaN、
  - 字符串：
    - 空字符串返回0
    - 字符串纯数字（包含浮点数）（有无符号）转换为十进制数值，如果前面有0直接忽略
    - 进制数字字符串会转换为十进制数字
    - 其余都转换为NaN
  - 对象，先调用valueOf方法，然后按照上面规则转换。结果为NaN,则调用toString()方法，再按照转换字符串的规则转换
- parseInt和parseFloat的方法差不多，一个是转换为整数，一个是转换为浮点数（如果本身就是整数，那么和parseInt一样）
  - 相比于Number, 这两个方法要相对宽松很多，首先排除前面空格（Number也会）、然后读取第一个字符串是否是数字（十进制），如果是则继续，解析到不是数字为止，然后裁切并返回；如果第一个不是数字则会直接返回NaN
  - 空字符串会返回NaN
  - parseInt 有第二个参数，表示进制， 代表第一个参数是几进制表示的。如果解析到浮点数，则会保留整数部分
  - parseFloat 始终解析10进制，如果是16进制则会返回0，且不能指定底数




## String


**string类型是一组由16位值组成的不可变的有序序列（需要必须先销毁原始字符串，然后新值保存在该变量中）**，每个字符通常来自于Unicode字符集。JS中通过字符串类型来表示文本。字符串长度是其所含16位值得个数。JS中字符串（和数组）的索引都是从0开始的

JS采用UTF-16编码的Unicode字符集，是由一组无符号的16位值组成的序号。最常用的Unicode字符都是通过16位的内码表示，并代表字符串中的单个字符，那些不能表示为16位的Unicode字符则遵循UTF-16编码规则——用两个16位值组成的一个序列表示。这意味着一个长度为2的JS字符串有可能表示一个Unicode字符，一般情况表情是占用两个字符的。JS定义各式字符串操作方法均作用于16位值，而非字符，且不会对代理项做单独处理，同样JS不会对字符串做标准化的加工，甚至不能保证字符串是合法的的UTF-16格式

字符串表示可以使用单引号，双引号或反引号包裹内容，在ES3字符串只能写在一行，ES5可以拆分多行，使用反斜杠(\)结束，反斜杠和行结束符都不算是字符串直接量的内容。如果希望在字符串中另起一行，可以使用转义字符\n

注意当使用单引号字符串时需要小心在里面使用单引号，需要使用反斜杠（\）转义

string类型转换规则如下：

- 基本数据类型，默认直接调用toString方法
- 引用数据类型。
  - 判断是否有toString()方法，且调用返回原始值
  - 否则判断是否有valueOf()方法，且调用返回原始值
  - 如果两者都没有将抛出一个类型错误异常
- 数组的默认toString()方法经过重新定义，将所有单元字符串化后再用 ',' 分隔，连接起来。

null和undefined一般没有toString()方法, 如果需要把他们转换为字符串需要显示调用String()函数

- `JSON.stringify()`在将JSON对象序列化为字符串时也用到了ToString的相关规则：
  - 大多数情况下JSON字符串化和toString()效果基本相同，只不过序列化的结果总是字符串（42 -> "42"、"42" -> ""42""、null -> "null"、"true" -> "true"）,所有安全JSON值都可以使用该方法
  - 不安全的JSON值：undefined、function、symbol和循环引用的对象（报错）都不符合JSON结构的标准，如果该方法遇到则会忽略返回undefined， 如果是数组中则返回null, 如果对象中使用，则会直接删除该字段
  - 如果对象中定义了toJSON()方法，JSON字符串化时会首先调用该方法，然后用它的返回值来序列化
  - 如果含有非法JSON值得对象做字符串化，或对象中的某些值无法序列化，就需要重新定义toString()方法类返回一个安全的JSON值

```javascript
const a = {}
const b = {
  n: 42,
  a,
  f: function(){}
}
a.e = b; // 产生了循环引用

// JSON.stringify(b) // 报错

// 自定义JSON序列化
b.toJSON = function() {
    return { n: this.n }
}
JSON.stringify(b) // "{ "n": 42 }"
```






## Boolean

JS中的值可以分为以下两类：

- 可以被强制类型转换为false的值：
  - 空字符、
  - 0、
  - NaN
  - null、undefined
- 其他（被强制类型转换为true的值）（所有对象（函数和数组）都转换为true.包装对象也是这样）



## 一元操作符

`++`与`--`无论是前缀还是后缀，变量值都会在语句被求值之前或之后改变（在计算机科学中，通常叫副作用）。这种操作符可以适用于任意数据类型，但是遵循以下操作：

- 字符串：如果是有效数值形式（使用Number()进行判断），则转换为数值再改变。变量类型从String -> Number；如果不是有效数值则会返回NaN。
- bool：如果是false则转换为0， true则为1。变量类型从Boolean -> Number
- object: 变量类型从Boolean -> Number
  - array: 对象具有valueOf() 方法，返回一个原始值，JS则会将其转换为数字；否则，如果对象具有toSting方法，返回原始值，JS将其转换并返回，否则，JS抛出一个类型错误异常
  - 其他：如果对象具有toString()方法，调用返回一个原始值，JS则会将其转换为字符串；否则，如果对象具有valueOf() 方法，调用返回一个原始值，JS则会将其转换为字符串；JS无法从toString()或valueOf方法获得一个原始值，将会抛出一个类型错误异常

一元加减`+`、`-`同理。如果放在`=`前面就是计算。如果放在变量前面就是改变变量的符号，正数改为负数，负数改为正数。

## 位运算符

JS操作内存中表示数据的比特（位）。ECMAScript中的所有数值都以IEEE 754 64位格式存储，但位操作并不直接应用到64位表示，而是先把值转换为32位整数，再进行位操作，之后再把结果转为64位。对于开发者而言，就好像只有32位整数一样，因为64位整数存储格式是不可见的。那么只需要考虑32位整数即可。这也让二进制操作变得与其他语言中类似。但这个转换也导致了一个奇特的副作用，就是特殊值NaN与Infinity在位操作中都会被当成0处理。

有符号32位表示：左边第一位代表符号位。0表示正、1表示负。 如果是正值，以二进制格式存储。如果是负值，则以**二补数**的二进制编码存储

::: tip 二补数计算
1. 确定绝对值的二进制表示（如-18， 先确定18的二进制表示）
2. 然后二进制各位取反（0变1,1变0）
3. 得到的二进制 + 1
:::

如果将位运算符应用到非数值，那么首先会使用Number()函数将该值转换为数值，然后在应用位操作。最终得到数值

```javascript
const num1 = 25 
// ~num1 // -26 64进制表示，然后各位取反，转译10进制

const num2 = 25
-num1 -1 // -26
```

上面两个结果一样，但位操作的速度快的多。因为位操作符是在数值的底层完成。

- 按位与（`&`）：有假（0）即为假（0）；`25 & 3 = 1`
- 按位或（`|`）：有真（1）即为真（1）；`25 | 3 = 27`
- 按位异或（`^`）：想同为假（0），不同为真（1）；`25 ^ 3 = 26`
- 左移 （`<<`）：左移几位，在右边补几位0；如果有符号位，符号位保留；`2 << 5 = 64`
- 有符号位右移（`>>`）：右移几位，在符号位右边补几位0；`64 >> 5 = 2`
- 无符号位右移（`>>>`）：对于正数，无符号右移与有符号右移结果相同。但是负数差别就很大：无符号右移将负数的二进制表示当成整数的二进制表示来处理，如下代码：

```javascript
const value = -64; 
// 64 -> 0000 0000 0000 0000    0000 0000 0100 0000
//取反 -> 1111 1111 1111 1111    1111 1111 1011 1111
//+1  -> 1111 1111 1111 1111    1111 1111 1100 0000
value >>> 5 // 134 217 726
// 无符号右移 会把它当成正数处理
//    -> 0000 0011 1111 1111    1111 1111 1111 1110    0000 0 
//    -> 0000 0011 1111 1111    1111 1111 1111 1110
```

## bool操作符

> 布尔运算符一共三个：逻辑非（`!`）、逻辑与（`&&`）、逻辑或（`||`）。

**逻辑非**

可以应用于任何数据类型，都会返回boolean值。逻辑非操作首先将操作值转换为bool值，然后再对其取反。逻辑非遵循的规则如下都是返回true（与bool转换刚好相反）：

- 空字符、
- 0、
- NaN
- null、undefined

同时使用`!!`相当于调用`Boolean()`

**逻辑与**

逻辑与操作符可用于任何类型的操作数，不限于bool值。如果有操作数不是bool值，则逻辑与并不一定会返回boolean值，而是遵循以下规则：

- 如果第一个值为假值，就会直接返回相应的假值（空字符串、0、NaN、null、undefined、false），不会对第二个值进行求值
- 如果第一个值为真值，那么直接返回第二个值

**逻辑或**

- 如果第一个值为假值，那么就会返回第二个值
- 如果第一个值为真值，那么直接返回第一个值

## 乘性、除法、指数、加减操作符

> 乘性操作符： 乘法、除法和取模。乘性操作符不是数值的操作数，则该操作数会在后台被使用`Number()`转型函数转换为数值。这意味者假值就会被转换为0

乘法操作符会遵循以下规则：

- 如果ECMAScript不能表示乘积，则返回`Infinity`或`-Infinity`
- 使用Infinity进行计算也会返回Infinity, 符号位保留
- 如果有任意操作数为NaN, 则返回NaN。Infinity * 0，也会返回NaN
- 如果不是数值的数，则会进行`Number()`转换，然后进行上诉规则

除法操作符会遵循以下规则：

- 如果ECMAScript不能表示商，则返回`Infinity`或`-Infinity`
- Infinity除以任何值，都会返回Infinity, 符号位保留；非0的有限值除以0 也一样
- 如果有任意操作数为NaN, 则返回NaN；使用Infinity除以Infinity, 会返回NaN; 0 除以 0也会返回NaN
- 如果不是数值的数，则会进行`Number()`转换，然后进行上诉规则

取模操作符会遵循以下规则：

- 如果被除数是无限制，除数是有限值；有限值除以0；Infinity除以Infinity，都会返回NaN
- 被除数是有限值，除数是无限制，则返回除数
- 被除数是0，除数不是0，则返回0
- 如果不是数值的数，则会进行`Number()`转换，然后进行上诉规则

ES7新增了指数操作符：`Math.pow()` -> `**`

加法操作符遵循规则如下：

- NaN计算返回NaN
- Infinity 进行计算返回 Infinity，符号位保留。但是Infinity和自己进行计算返回NaN
- 0 与 0 进行计算返回0， 符号位两个都是负号，则返回`-0`，其他返回`+0`
- 操作数字符串，使用如下规则：
  - 如果两个操作数都是字符串则进行拼接
  - 如果只有一个操作数是字符串，则将另一个转为字符串，然后进行拼接。
- 如果有一个是对象、数值、bool,则调用toString()方法以获取字符串，然后在应用前面的关于字符串规则。对于undefined和null,则调用String()函数，分别获取"undefined"、"null"

减法操作符遵循规则如下：

- NaN计算返回NaN
- 同符号 Infinity进行计算返回NaN, 否则返回Infinity, 符号位保留第一位的符号
- 0 与 0 进行计算返回0， 符号位两个不同负号，则返回`-0`，想同返回`+0`
- 如果任一操作数是字符串、bool、null或undefined，则会使用Number()将其转换为数值，然后根据前面执行数学运算。如果转换结果为NaN,则计算结果是NaN
- 如果任一操作数是对象，则调用其valueOf()方法，取得表示它的数值。如果该值是NaN,则减法计算的结果是NaN.如果对象没有valueOf()方法，则调用其toString()方法，然后在将得到的字符串转为数值。

## 关系操作符

关系运算符比较两个值得操作，包括`小于（<）`、`大于（>）`、`小于等于（<=）`、`大于等于（>=）`。这几个操作符都返回bool值，遵循规则如下：

- 如果操作符都是数值，则直接比较
- 任何涉及NaN都会返回false
- 如果操作数是字符串，则逐个对比字符串中的编码（注意：大写字母小于小写字母）。
- 如果任一操作数是数值，则将另一个转换为数值，执行比较大小
- 如果任一操作数是对象，则调用其valueOf方法，取得结果后再根据前面的规则执行比较；如果没有valueOf则调用toString方法，取得结果后再根据前面的规则执行比较
- 如果任一操作数是bool值，则将其转换为数值，然后执行比较

## 相等运算符

不全等`==`和不相等`!=`遵循如下规则：

- 如果任一操作数是bool值，则将其转换为数值再比较是否相等
- 如果一个操作数是字符串，另一个是数值，则会将字符串转换为数值（Number），再比较是否相等
- 如果一个操作数是对象，另一个不是，则调用对象的valueOf()方法取得其原始值，再根据前面的规则进行比较
- null 与 undefined 相等
- null 与 undefined 不能转换为其他值进行比较（例如 `null == 0`、`undefined == 0`, 都是返回false）
- 如果任意操作数是NaN,则相等操作符返回false,不相等操作符返回true.
- 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象地址

`全等`和`不全等`规则是：在比较的时候不转换操作数进行比较。

## 语句


```javascript
// 1. if语句：判断会涉及隐式类型转换
if(condition) {
    
} else if(condition) {
    
} else { }

// do-while: 先执行循环体里面的内容，然后执行退出条件进行求值
do {
  // staement
} while(expression)

// while
while(expression) {}

// for-in 用于枚举对象中的非符号键属性
Object.defineProperty(target, key, {
  configurable: true,
  enumerable: false, // 设置不可枚举
  writable: true,
  value,
})
for(const key in target) {}
// for-of 语句是一种严格的迭代语句，用于遍历可迭代对象元素，一般用于数组
for(const item of arr) {}

/**
 * break、continue、return
 *      break 用于立即退出循环。而continue 只是退出当前循环（不执行后面代码），下一次接着继续
 *      return 退出函数作用域
 */

// with 将代码作用域设置为特定的对象（不推荐使用）


```




