# 应用层

网络应用是极端及网络存在的理由，如果不能构想出任何有用的应用，也就没有任何必要去设计支持它们的网络协议了。

应用层其中包括应用程序所需要的网络服务、客户、服务器、进程和传输接口。

## 应用层协议原理

研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序。例如，在网络应用程序中，有两个互相通信的不同程序：一个是运行在用户主机上的浏览器程序；另一个是运行在 Web 服务器主机上的 Web 服务器程序。

在研发新的应用是，需要编写多端系统上运行软件，该软件不需要写在网络核心设备设备（如路由器或链路层交换机上）运行软件，及时想要做也做不到。网络核心设备并不在应用层上起作用，而仅在较低层起作用，特别是在网络层及下面层级起作用。这种设计将应用软件限制在端系统的方法，促进大量的网络应用程序迅速的研发和部署。


### 网络应用程序体系结构


网络应用程序中有两种主流体系机构之一：客户-服务器体系结构 或 对等（p2p）体系结构。

在客户-服务器体系结构（client-server architecture）：一台服务器，服务大量客户主机请求。典型的例子就是web应用程序，比如淘宝网一台服务器，服务于众多逛淘宝的群众主机的请求。当web服务器接收到来自客户的请求时，它向该客户发送所请求的对象作为响应。一个服务器对应多个客户主机请求。另外服务器的固定ip地址不能变，这样客户就能通过服务器的ip地址发送分组来与其联系。具有客户-服务器体系结构的应用程序有web、ftp、telnet和电子邮件。

这种客户-服务器体系结构存在弊端，如果访问量增加，服务器就会跟不上所有客户请求的情况。例如淘宝双11活动，如果用一台服务器支撑，很快就会瘫痪的。为此，配备大量主机的数据中心被用于创建强大的虚拟服务器。例如搜索引擎(谷歌、Bing和百度)、互联网商店(亚马逊、e-Bay 和阿里巴巴)、基于 Web 的电子邮件(Gmail 和 雅虎)、社交网络(脸书、Instagram、推特和微信)，就是用了多个数据中心。


另外一种体系结构是 P2P体系结构(P2P architecture)，相对于对数据中心有过多依赖的客户-服务器体系结构，P2P 体系结构则直接通过两台相连的主机直接通信，这些主机称为对等方。典型的 P2P 体系结构的应用包括 文件共享(BitTorrent)、下载器(迅雷)、互联网电话和视频会议(Skype)。

P2P 体系结构最重要的一个特性就是它的自扩展性(self-scalability)。例如，在一个 P2P 文件共享的应用中，尽管每个对等方都由于请求文件产生工作负载，但每个对等方通过向其他对等方分发文件也为系统增加服务器能力。然而，未来p2p应用由于高度非集中式结构，面临安全，性能和可靠性等挑战。

![](./img/part1.png)

### 进程通信

在操作系统中进行通信的是进程（process）而不是程序。一个进程可以被认为是运行在端系统中的程序。当多个进程运行在系统的端系统上，进程间通信机制互相通信。进程间通信的规则由端系统上的操作系统确定（不关注同一台主机进程通信，而是关注不同主机间的通信）。

**1. 客户和服务器进程**

网络应用程序由成对的进程组成，这些进程通过网络相互发送报文。例如，在web应用程序中，客户端与服务端进程交换报文。在一个p2p文件共享系统中，文件从一个对等方中的进程传到另一个对等方中的进程。

在一堆进程之间的通信会话场景中，发起通信的进程被标识为客户，在会话开始时等待联系的进程是服务器。web应用程序很好理解，浏览器就是客户。但是在p2p中，一个进程即可以是客户又可以是服务器，因为它即能上传又能下载。


**2. 进程与计算机网络之间的接口**

多数应用程序是由通信进程对组成，每对中的两个进程互相发送报文。从一个进程向另一个进程发送的报文必须通过下面的网络。进程通过一个称为套接字（socket）的软件接口向网络发送报文和从网络接收报文。

socket是同一台主机内应用层与传输层之间的接口。由于该socket是简历网络应用程序的可编程接口，因此socket也叫应用程序和网络之间的应用程序编程接口（Application Programming Interface, API）.

应用程序开发者可以控制socket在应用层端的一切，但对该socket的传输层端几乎没有控制权。开发者对于传输层的控制仅限于：选择传输协议、也许能设置几个传输参数，如最大缓存和最大报文段长度等。一旦应用程序开发者选择一个传输协议，则应用程序就建立在该协议提供的传输层服务之上。

**3. 进程寻址**

在两台主机进程间通信，接收进程需要地址。那么接收进程需要定义两种信息：服务端地址、服务端接收进程的标识。

在因特网中，主机由其ip地址表示，ip地址是一个32比特的量且特能够唯一地标识该主机。现在主机解决了，还有一个服务端接收进程的标识。计算机中还有端口号，用来识别网络中的进程，从而实现进程间的通信。在操作系统中一个进程必须绑定一个端口号才能进行网路通信。例如web服务器占用80端口，邮件服务器（SMTP）25端口、ftp服务占用21端口等。


### 可供应用程序使用的运输服务



一个传输层协议能为该应用程序提供什么服务？一般能够从四个方面对应用程序服务要求进行分类：可靠数据传输、吞吐量、定时和安全性。

**1. 可靠数据传输**

分组在计算机网络中可能丢失，某些应用程序（web文档传输、金融应用、电子邮件、文件传输、远程主机访问等）数据丢失会造成灾难性的后果，因此为了支持这些应用，必须做一些工作以确保应用程序的一端发送的数据正确、完全地交付给另一端应用程序。如果一个协议提供了这样的确保数据交付服务，就认为提供**可靠数据传输**。

当传输层协议不提供可靠的数据传输是，由发送进程发送的某些数据可能到达不了接收进程，这可能被**容忍丢失的应用**所接收，最值得注意的是多媒体应用（音视频），它能能够承受一定量的数据丢失。


**2. 吞吐量**

吞吐量就是发送进程能够向接收进程交付比特的速率。因为其他会话共享占用该网络带宽，吞吐量将随时间波动。 具有吞吐量要求的应用程序称为**带宽敏感应用**，如果运输协议不能提供这种吞吐量，该应用程序或以较低速率进行编码（并且接受足够的吞吐量以维持这种较低的编码速率），或可能必须放弃发送，这是因为接收所需的吞吐量根本没用。应用有电话、网络视频、在线游戏、流媒体服务等。而**弹性应用**能够根据当时可用带宽或多或少地利用可供使用的吞吐量，应用有电子邮件、文件传输、web传输等。吞吐量越多越好。

**3. 定时**

传输层协议也能提供定时保证。如同具有吞吐量保证那样，定时保证能够以多种形式实现。

定时能够确保网络中两个应用程序的收发是否能够在指定的时间内完成，这也是应用程序选择运输服务需要考虑的一个因素，这听起来很自然，你网络应用发送和接收数据包肯定要加以时间的概念，比如在游戏中，你一包数据迟迟发送不过去，对面都推塔了你还卡在半路上呢。

**4. 安全性**

传输层能够为应用程序提供一种或多种安全性服务。例如，在发送主机中，传输协议能够加密由发送进程的所有数据，在接收主机中，传输层协议能够将数据交付给接收进程之前解密这些数据。这种服务将在发送和接收进程之间提供机密性，以防该数据以某种方式在两个进程之间被观察到。传输层协议还能提供除了机密性以外的其他安全服务，包括数据的完整性和端点的鉴别。

### tcp和 udp

上面提了计算机网络能够提供的通用传输服务。现在可以看因特网提供的传输服务类型。因特网（一般是tcp/ip网络）为应用程序提供两个运输协议，即udp和tcp。在创建一个应用程序之前需要考虑选择udp还是tcp,每个协议为调用它们的应用程序提供了不同的服务集合。

**1. tcp**

tcp服务模型包括面向连接服务和可靠数据传输服务。当某个应用程序调用tcp作为其传输协议时，该应用程序就能获得来自tcp的这两种服务

| 应用     | 数据丢失 | 带宽         | 时间敏感    |
|--------|------|------------|---------|
| 文件传输   | 不能丢失 | 弹性         | 不       |
| 电子邮件   | 不能丢失 | 弹性         | 不       |
| web文档  | 不能丢失 | 弹性 (几kb)   | 不       |
| 网络电话   | 容忍丢失 | 几kb ~ 1mb  | 是，100ms |
| 网络视频   | 容忍丢失 | 10kb ~ 5mb | 是，100ms |
| 流式存储音频 | 容忍丢失 | 几kb ~ 1mb  | 是，几秒    |
| 流式存储视频 | 容忍丢失 | 10kb ~ 5mb | 是，几秒    |
| 交互式游戏  | 容忍丢失 | 几kb ~ 10kb | 是，100ms |
| 智能手机讯息 | 不能丢失 | 弹性         | 是和不是    |


- 面向连接：在应用层数据报文开始流动之前，tcp让客户和服务器互相交换传输层控制信息。这个所谓未收过程提醒客户和服务器，让它们为大量分组的到来做好准备，在握手阶段后，一个tcp连接就在两个进程的socket之间建立。这条连接是全双工的，即连接双方的进程可以在此连接上同时进行报文收发。当应用程序结束报文发送时，必须拆除该连接。
- 可靠的数据传输服务：通信进程能够依靠tcp，无差错、按适当顺序交付所有发送的数据。当应用程序一段将字节流传入socket时，它能够依靠tcp将形同的字节流交付给接收方的socket，而没有字节的丢失和冗余。

tcp协议还具有拥塞控制机制，这种服务不一定能为通信进程带来直接好吃，但能为因特网带来整体好处。当发送方和接收方之间的网络出现拥塞时，tcp的拥塞控制机制会抑制发送进程。tcp拥塞控制也试图限制每个tcp连接，使得它们达到公平的共享网络带宽的目的。

::: tip tcp安全
无论tcp还是udp都没有提供任何加密机制，这就是说发送进程传进socket的数据经过网络传输到达目的的数据想同。如果一个发送进程以明文方式发送口令进入socket，该明文口令将经过发送方与接收方之间的所有链路传送，这就可能在任何中间链路被嗅探和发现。因为隐私和其他的安全问题对许多应用而言很重要，所以因特网界研究tcp的加强版，称为"安全套接字层（Secure Sockets Layer, SSL）"。用SSL加强后的TCP不仅能够做传统的tcp所能做的一切，而且提供了关键的进程到进程的安全服务，包括加密、数据完整性、端点鉴别。我们强调SSL不是与TCP和UDP在想同层次上的第三种因特网传输协议，而是一种对tcp的加强，这种强化实在应用层实现的。特别是，如果一个应用程序要使用SSL服务，它需要在该应用程序的客户端和服务器端包括SSL代码（利用现有的、高度优化的库和类）。SSL有它自己的socket api，这类似于传统的tcp socket api。当一个应用使用SSL时，发送进程向SSL socket传递明文数据;在发送主机中的ssl则加密该数据并将加密的数据传递给tcp socket。该接收socket将加密数据传递给ssl, 由其解密。最后ssl通过它的ssl socket将明文数据传递给接收进程。
:::


**2. udp**

udp是一种不提供不必要服务的轻量传输协议，它仅提供最小服务。udp是无连接的，因此在两个进程通信前没有握手过程。udp协议提供一种不可靠数据传送服务，也就是说，当进程将一个报文发送进udp socket 时，udp协议并不保证该报文将到达接收进程。也有可能接收进程是乱序到达。

udp没有拥塞控制机制，所以udp的发送端可以用它选定的任何速率向其下层（网络层）注入数据。


| 应用     | 应用层协议                                   | 支撑的运输协议  |
|--------|-----------------------------------------|----------|
| 电子邮件   | SMTP [RFC 5321]                         | TCP      |
| 远程终端访问 | Telnet [RFC 853]                        | TCP      |
| web    | HTTP [RFC 2616]                         | TCP      |
| 文件传输   | FTP [RFC 959]                           | TCP      |
| 流式多媒体  | HTTP [bilibili]                         | TCP      |
| 因特网电话  | SIP [RFC 3261]、RTP[RFC 3550]或专用的（Skype） | TCP 或udp |

上表中使用tcp的主要原因就是可靠的数据传输服务，确保所有数据最终到达目的地。最后一桶通常能够容忍某些丢失但要求达到一定的最小速率才能有效工作，所以因特网电话应用的开发者更愿意使用udp, 从而避开tcp的拥塞控制机制和分组开销。但因为许多防火墙被配置成阻挡udp流量，索引通常设计成如果udp通信失败就使用tcp作为备份。


### 应用层协议

应用层协议定义运行在不同端系统上的应用程序进程如何相互传递报文。特别是应用层协议定义了：

- 交换的报文类型，例如请求报文和响应报文
- 各种报文类型的语法，如报文中的各个字段及这些字段是如何描述的
- 字段的含义，即这些字段中的信息含义
- 确定一个进程何时以及如何发送报文，对报文进行响应的规则

有些应用协议是由RFC文档定义的，因此它们位于公共域中。例如web的应用层协议http（超文本传输协议[RFC 2616]）就作为一个RFC可供使用。如果浏览器开发者遵从HTTP RFC规则，所开发出的浏览器就能访问任何遵从该文档标准的web服务器并获取相应的web页面。还有很多别的应用层协议是专用的，有意不为公共域使用。例如Skype使用专用的应用层协议。



## web 和 HTTP

web的应用层协议是超文本传输协议（HyperText Transfer Protocol, HTTP）,它是web的核心，在[RFC 1945]和[RFC 2616]中定义了。HTTP由客户端和服务端程序通过交换HTTP报文进行会话。HTTP定义了这些报文的结构以及进行报文交换的方式。


web页面（web page）也叫文档是由对象组成。一个对象只是一个文件，比如一个html文件、jpeg图、视频片段这样的文件，且它们通过一个URL地址寻址。多数web页面含有一个HTML文件以及几个引用对象。
例如，如果一个web页面包含html文本和5个jpeg图，那么这个web页面就有6个对象，html文件通过对象的url地址引用页面的其他对象，每个url地址由两部分组成：服务器主机名和路径名。
例如url地址`http://www.someSchool.edu/comeDepartment/picture.gif`,其中`www.someSchool.edu`就是主机名，后面的就是路径名。web浏览器实现了http的客户端，web服务器实现了http服务端，用于存储web对象，每个对象由url寻址。

http定义web客户端向服务器请求web页面的方式，以及服务器向客户端传送web页面的方式。当用户请求一个web页面时，浏览器向服务器发送对该页面中所包含对象http请求报文，服务器接收到请求并用包含这些对象的http响应报文进行响应。

http使用tcp作为传输协议。http客户首先发起一个与服务器的tcp连接。一旦连接建立，浏览器与服务器进程就可以通过socket接口访问tcp。客户端的socket接口是客户端进程与tcp连接的门。服务器端的socket接口则是服务器进程与tcp连接之间的门。
客户端向socket接口发送http请求报文并从它的socket接口接收http响应报文。服务端类似，服务端从它的socket接口接收http请求报文和向它socket接口发送http响应报文。一旦客户端向它的socket接口发送一个请求报文，该报文就脱离客户控制并进入tcp的控制。

![](./img/http1.png)


### 非持续连接和持续连接（短连接和长连接）

**非持续连接 HTTP/1.0**： 每个请求、响应报文是经过单独的tcp连接发送，每个tcp连接在服务器发送一个对象后关闭，该连接并不为其他的对象而持续下来。也就是每个tcp只传输一个请求和一个响应。

从服务器向客户端传送web页面, 假设该页面有一个html基本文件和10个jpeg图形，并且这11个对象位于同一个服务器上。请求html url:`http://www.someSchool.edu/comeDepartment/index.html`,会经历如下步骤：

- http客户端进程在80发起一个到服务器`www.someSchool.edu`的tcp连接，该端口号是http默认端口。在客户和服务器上分别有一个socket与该连接相关联。
- http客户端经它的socket向该服务器发送一个http请求报文。请求报文中包含路径名`/comeDepartment/index.html`
- http服务器进程经它的socket接收该请求报文，从其存储器中检索出对象`www.someSchool.edu/comeDepartment/index.html`,在一个http响应报文中封装对象，并通过其socket向客户端发送响应报文。
- http服务器进程通知tcp断开该tcp连接（但是直到tcp确认客户已经完整地收到响应报文为止，它才会实际中断连接）
- http客户端接收响应报文，tcp连接关闭。该报文支出封装的对象是一个html文件，客户从响应报文中提取出该文件，检查该html文件，得到10个jpeg图形的引用。
- 对每个引用的jpeg图形对象重复1-4步骤。



响应时间模型：一个小的分组从客户端到服务器，再回到客户端的时间（传输时间忽略）被称为往返时间（Round-Trip Time, RTT）。

响应时间： 一个RTT用来发起tcp连接、一个RTT用来http请求并等待http响应、文件传输时间。以供2RTT + 传输时间


![](./img/RTT.png)

**持续连接 HTTP/1.1**：服务器在发送响应后保持tcp连接状态打开，一般来说，如果一条经过一个时间间隔仍然未被使用，http服务器就会关闭这个连接。

非持续连接有一些缺点。第一：必须为每一个请求的对象建立和维护一个全新的连接。对于每个这样的连接，在客户和服务器中都要分配tcp的缓冲区和保持tcp变量，这个服务器带来严重负担，因为一台服务器有可能服务很多客户请求。第二：每个对象经受两倍RTT的交付时延，即一个RTT用于创建tcp, 另一个用于请求和接收一个对象。

在采用http1.1持续连接的情况下，服务器在发送响应后保持该tcp连接打开。在相同的客户与服务器之间，后续的请求和响应报文能够通过相同的连接进行传送。特别是，一个完整的web页面可以用单个持续tcp连接进行传送。更有甚者，位于同一台服务器的多个web页面在从该服务器发送给同一客户时，可以在单个持续tcp连接上进行。对对象的这些请求可以一个接一个的发出去，而不必等待上一个响应完成（异步）。
一般来说，一条连接经过一定的时间间隔（可配置超时间隔）仍被使用，http服务器就该关闭该连接。http的默认模式是使用同步（等上一个请求完成）是持续连接。

http/2是在http1.1基础上构建的，它允许在相同连接中多个请求和回答交错，并增加了在该连接中优化http报文请求和回答机制。

![](./img/part2.png)



### http报文格式

HTTP规范包含了对HTTP报文格式的定义。HTTP报文有两种：请求报文和响应报文

### 请求报文

```shell
GET /prod-api/system/user/list?pageNum=1&pageSize=10&userName=admin HTTP/1.1
Accept: application/json, text/plain, */*
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6
Authorization: Bearer eyJhbGciOiJIUzUxMiJ9.eyJsb2dpbl91c2VyX2tleSI6ImNjMzYxN2U3LTQ5ODQtNDQ0ZC04OWM5LTFkMTg1YTY5ZDg2MyJ9.1OlxOIg6hCB_kW5-V4pMjcKpVNwS7HbUwp6LKgSVW28Plta3ARdajnfNhDpWa9Dusia2WBj6BMpetrAaNreITQ
Connection: keep-alive
Cookie: Hm_lvt_bb4f5da057f22a0134fd46d78ef35bae=1696594925; Admin-Token=eyJhbGciOiJIUzUxMiJ9.eyJsb2dpbl91c2VyX2tleSI6ImNjMzYxN2U3LTQ5ODQtNDQ0ZC04OWM5LTFkMTg1YTY5ZDg2MyJ9.1OlxOIg6hCB_kW5-V4pMjcKpVNwS7HbUwp6LKgSVW28Plta3ARdajnfNhDpWa9Dusia2WBj6BMpetrAaNreITQ
Host: vue.ruoyi.vip
Referer: http://vue.ruoyi.vip/system/user
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36 Edg/117.0.2045.60
```

这是一个若依管理系统里面的一个列表搜索的请求报文。上面报文的内容都是普通的ascii文本，开发者应该都认识。

![](./img/request.png)

请求方法包括：GET、POST、HEAD、PUT和DELETE。

首部行：

- accept 客户端期望接收的响应内容类型
- accept-encoding 客户端可以接收响应压缩编码。"gzip, deflate" 表示客户端可以接受使用GZIP或DEFLATE压缩算法压缩的响应。这些算法都是在HTTP协议中常用的数据压缩方式。
- accept-language 用户想得到该对象的语义化版本，否则发送默认版本
- Authorization 验证用户是否能够访问特定资源，一般来说，这通过在请求中包含一个认证（Authorization）标题来完成，该标题中包含了用于访问被请求资源的授权证书或访问令牌。授权协议有很多种，常见的有：
  - Basic Authentication：这是一种简单的认证协议，其中用户名和密码被编码并放在一个字符串中，该字符串被放在Authorization头中。服务器解码这个字符串并验证用户名和密码是否正确。
  - Digest Authentication：这是一种更安全的认证协议，其中密码不会被明文发送。相反，客户端和服务器都会进行一次哈希计算，以验证请求的合法性。
  - OAuth 1.0, 2.0：开放授权（OAuth）是一种标准的授权协议，它允许第三方应用程序获得有限的访问权限。用户授予应用程序特定的权限，然后应用程序使用这些权限来执行操作，就好像它们是用户一样。OAuth 1.0和2.0都有一些不同的变体和选项。
  - JWT (JSON Web Tokens)：这是一种基于令牌的认证和授权机制，其中包含用户信息和声明，并且可以被验证和信任。JWT可以使用密码或密钥进行签名，也可以使用公钥/私钥对进行加密。
- Connection: keep-alive。指定长连接，在完成当前请求后后不关闭，而是保持打开状态。close就是指定短连接，在完成当前请求后关闭
- Cookie：向服务器提供用户的身份认证信息或其他相关信息，格式`Cookie: name1=value1;name2=value2`
- host 指明对象所在的主机。其实主机中已经有一条tcp连接存在，这个信息是web代理高速缓存所要求的。
- Referer: 告诉服务器客户端是从哪个URL访问当前资源的
- user-Agent: 指明用户代理，即向服务器发送请求的浏览器类型。服务器可以有效地为不同类型的用户代理时机发送相同对象的不同版本。

![](./img/request1.png)


### 响应报文

```shell
HTTP/1.1 200
Connection: keep-alive
Content-Type: application/json
Date: Tue, 17 Oct 2023 12:04:30 GMT
Server: nginx
Transfer-Encoding: chunked
Vary: Access-Control-Request-Headers
Vary: Access-Control-Request-Method
Vary: Origin
X-Content-Type-Options: nosniff 
X-XSS-Protection: 1; mode=block
```

![](./img/request2.png)

- Connection: keep-alive 表示服务器保持长连接，而不是对每个请求开启一个新连接。close服务器保持短连接
- Content-Type: application/json 返回内容json格式
- Date：服务器生成并发送该响应报文的日期和时间。这个时间不是对象创建或者最后修改时间，而是服务器从它的文件系统中检索到该对象，并将对象插入响应报文中，并发送该响应报文的时间。
- Server：表示该报文是一台nginx服务器产生。
- Transfer-Encoding: chunked: 表示响应使用了分块传输编码。
- Vary: Access-Control-Request-Headers, Vary: Access-Control-Request-Method, Vary: Origin: 这些头用于支持缓存和跨域资源共享（CORS）。
- X-Content-Type-Options: nosniff: 阻止浏览器猜测响应的内容类型。
- X-XSS-Protection: 1; mode=block: 该头用于启动大多数现代Web浏览器的反射型跨站脚本保护
- Content-Length: 被发送对象中的字节数
- last-Modified: Tue, 18 Aug 2023 12:11:03 GMT 表示资源最后一次修改时间。如果浏览器想要验证文档是否最新，就会使用响应头该字段与浏览器缓存中的值进行比较，如果一致返回304状态码，如果不同则重新下载文档。


## cookie

http服务器是无状态的，然后在很多场景系统希望能够识别用户，为此HTTP使用了cookie,它允许站点对用户进行跟踪。cookie技术有4个组件：

1. 在HTTP响应报文中的cookie首部行
2. 在HTTP请求报文中的一个cookie首部行
3. 在用户端系统中保留一个cookie文件，由用户的浏览器进行管理
4. 在服务端数据库，

![](./img/cookie.png)

用上图举个例子，当Susan用户首次访问eBay的站点，服务器判断没有登录，于是发送响应头重定向到登录页面，然后Susan进行登录，那么服务器就会产生一个唯一识别码，并以此作为索引存在它们后端的数据库中，接下来服务器用一个包含`set-cookie： 1678`的响应报文发送给客户端。然后浏览器就会把这个cookie存储下来，每次进行请求的时候都会带上这个cookie。在这种方式下该服务器可以跟踪客户端在该服务器上面的所有行为。尽管服务器不用知道客户端那边是谁，但它知道用户1678按照什么顺序，什么时间、访问哪些页面。

尽管cookie常常用于能够简化用户的购物活动，但是它对用户隐私也是一种侵害。结合cookie和站点注册的用户信息，站点可以知道很多用户信息，并可能卖给第三方。


## web缓存

web缓存器也叫代理服务器，它是能够代表初始web服务器来满足http请求的网络实体。web缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过对象的副本。

![](./img/request3.png)

web缓存器通常由ISP购买并安装。在因特网上部署web缓存器有两个原因。首先web缓存器可以大大减少对客户端请求的响应时间，特别是客户端与源服务器之间的瓶颈带宽远低于客户端。如果客户端与web缓存器之间有一个高速连接，并且如果用户所请求的对象在web缓存器上，则web缓存器能够大大减少一个机构的接入链路到因特网的通信量。通过减少通信量，该机构就不必着急增加带宽，因此降低了费用。此外web缓存器能从整体上大大减低因特网上的web浏览，从而改善了所有应用的性能。

## 条件get

高速缓存能减少用户的响应时间，但是存放在缓存中的对象可能就旧的。因此http协议有一种机制，允许缓存器证实它的对象是最新的，这种价值就是**条件get方法**。如果请求报文中使用get方法，并且请求报文中包含`if-modified-since`，那么这个http请求报文就是一个条件get请求报文。服务端对这个报文键进行对比，时间是否发生变化，如果没有web服务器仍然发送一个响应报文，但没有在该响应报文中包含所请求的对象。包含对象会浪费带宽和增加响应时间，报文中状态为`304 Not Modified`,它高速缓存器可以使用该对象，能向请求的浏览器转发缓存的副本。



